using Mutagen.Bethesda;
using Mutagen.Bethesda.Environments;
using Mutagen.Bethesda.Oblivion;
using Mutagen.Bethesda.Plugins.Exceptions;
using Mutagen.Bethesda.Synthesis;

namespace TMPatcher
{
    public class Program
    {
        private static Lazy<Settings> _settings = null!;
        private static Settings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IOblivionMod, IOblivionModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.Oblivion, "TMPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<IOblivionMod, IOblivionModGetter> state)
        {
            Console.WriteLine("\n\nRunPatch`Open\n");
            var changeCount = 0;
            // FeatureAdjustLocks
            if (Settings.FeatureAdjustLocks)
            {
                foreach (var context in state.LoadOrder.PriorityOrder.PlacedObject().WinningContextOverrides(state.LinkCache))
                {
                    try
                    {
                        var baseZ = context.Record.Base.TryResolve<IContainerGetter>(state.LinkCache);
                        if (baseZ != null && context.Record.Lock != null && context.Record.Lock?.LockLevel < Settings.FeatureAdjustLocks_MinimumLockLevel)
                        {
                            Console.WriteLine($"Found locked container below minimum lock level. FormKey:{context.Record.FormKey} EditorID:{context.Record.EditorID} ModKey:{context.ModKey}");

                            var newRecord = context.GetOrAddAsOverride(state.PatchMod);
                            newRecord.Lock!.LockLevel = Math.Max((byte)Settings.FeatureAdjustLocks_MinimumLockLevel, newRecord.Lock!.LockLevel);
                            // TODO: Might also want to remove the "Auto level" flag
                            changeCount++;
                        }
                        else
                        {
                            // Console.WriteLine($"Does not match. FormKey:{context.Record.FormKey}. 1:{context.Record.Lock != null} 2:{context.Record.Lock?.LockLevel > Settings.FeatureAdjustLocks_MinimumLockLevel} 3:{baseZ != null}. context.Record.Lock?.LockLevel:{context.Record.Lock?.LockLevel}. Settings.FeatureAdjustLocks_MinimumLockLevel:{Settings.FeatureAdjustLocks_MinimumLockLevel}");
                            // if (context.Record.FormKey.ToString().Contains("0A81B2"))
                            // {
                            //     Console.WriteLine($"{context.Record.FormKey} LockLevel:{context.Record.Lock?.LockLevel}.");
                            // }
                        }
                    }
                    catch (Exception ex)
                    {
                        throw RecordException.Enrich(ex, context.Record);
                    }
                }
            }

            // FeatureGuaranteeCreatureSpeed
            if (Settings.FeatureGuaranteeCreatureSpeed)
            {
                foreach (var oldCreature in state.LoadOrder.PriorityOrder.WinningOverrides<ICreatureGetter>())
                {
                    try
                    {
                        if (oldCreature.Data == null)
                        {
                            Console.WriteLine($"Skipping oldCreature because Data was null. EditorID:{oldCreature.EditorID} Name:{oldCreature.Name}");
                            continue;
                        }

                        if (oldCreature.Data?.Speed >= 30)
                        {
                            Console.WriteLine($"Skipping oldCreature because Speed >= 30. EditorID:{oldCreature.EditorID} Name:{oldCreature.Name}");
                            continue;
                        }

                        var newCreature = oldCreature.DeepCopy();
                        newCreature.Data!.Speed = 30;
                        state.PatchMod.Creatures.Set(newCreature);
                        changeCount++;
                        Console.WriteLine($"Modified creature. FormKey.ModKey.Name:{newCreature.FormKey.ModKey.Name} EditorID:{newCreature.EditorID} Name:{newCreature.Name}");
                    }
                    catch (Exception ex)
                    {
                        throw RecordException.Enrich(ex, oldCreature);
                    }
                }
            }

            // FeatureGuaranteeOneIngredientEffect
            if (Settings.FeatureGuaranteeOneIngredientEffect)
            {
                // TODO: Find a better way to get an effect. Also, it might be better to get a different effect, like restore fatigue.
                IEffectGetter? nullableEffect = null;
                foreach (var ingredient in state.LoadOrder.PriorityOrder.WinningOverrides<IIngredientGetter>())
                {
                    try
                    {
                        Console.WriteLine("Before getting effect.");
                        nullableEffect = ingredient.Effects[0];
                        Console.WriteLine("After getting effect.");
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Couldn't get effect from ingredient.");
                    }
                }

                var effect = nullableEffect!;

                foreach (var oldIngredient in state.LoadOrder.PriorityOrder.WinningOverrides<IIngredientGetter>())
                {
                    try
                    {
                        if (oldIngredient.Effects.Count > 0)
                        {
                            Console.WriteLine($"Skipping ingredient because Count > 0. EditorID:{oldIngredient.EditorID} Name:{oldIngredient.Name}");
                            continue;
                        }

                        var newIngredient = oldIngredient.DeepCopy();
                        newIngredient.Effects.Add(effect.DeepCopy());
                        state.PatchMod.Ingredients.Set(newIngredient);
                        changeCount++;
                        Console.WriteLine($"Modified ingredient. EditorID:{newIngredient.EditorID} Name:{newIngredient.Name}");
                    }
                    catch (Exception ex)
                    {
                        throw RecordException.Enrich(ex, oldIngredient);
                    }
                }
            }

            Console.WriteLine($"\n\nRunPatch`Close. changeCount:{changeCount}\n");
        }
    }
}